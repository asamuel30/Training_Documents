			
************************
Day 11 : 11th Feb. 2025 
************************	

	Version Control System using GIT/Github :::
	
		Continuous Development ::
		
		
		index.html 
		
		<html>
		---
		--
		--
		---
		---
		-
		</html>
		
		save index.html 	test 
		
		edit index.html 

		<html>
		---
		--
		-----
		---@@@
		---@@@
		----
		--
		-
		-
		-----
		---
		--
		</html>	
		
		save index.html 	test 

		Version Control System 
		
			-> It is used to Version Control the Changes in files. 
			-> It is used to Track the File Changes.
		
		index.html 
		
		<html>
		---
		--
		--
		---
		---
		-
		</html>	
		
		
		save index.html					index.html_V1.0			# V1.0 is the tag/version_number/Commit_id
		
		edit index.html 

		<html>
		---
		--
		-----
		---@@@
		---@@@
		----
		--
		-
		-
		-----
		---
		--
		</html>	
		
		save index.html					index.html_V1.1			# V1.1 is the tag/version_number/Commit_id
		save index.html					index.html_V1.2	
		save index.html					index.html_V1.3	
		save index.html					index.html_V1.4	
		save index.html					index.html_V1.5



	Version Control System 
	
		-> It is used to Version Control the Changes in files. 
		-> It is used to Track the File Changes.
			
		Types of Version Control System :::
		
			1. Local VCS 
					- It is used only in a Local machine
					- Cannot possible to share the source code repositories to other.
					
			2. Centralized VCS
					- The Source Code Repositories and maintained in a central server.
					- Users should have valid access and should be Online to access the files from Centralized VCS.
					- If Users are offline / If the central server is down, then we cannot access the files. 
					- Users will not have any Copy of files in the local machine.
					
			3. Distributed VCS ::
					- The Source Code Repositories are maintained in a Remote Servers.
					- Users should have valid access remote Repositories.
					- If Users can work offline.
					- Copy of Files can be stored in the local machine.					
			
		GIT :::
		
			It is a Open-Source Distributed Version control System.
			It is used to version control the Changes 
			It is used to Track the Changes
			It is used to perform Parallel Development
				Parallel Development can be achieved using Branching Techniques. 

	Working with Distributed VCS - GIT/Github :::	
	
		- Install git Client in the Local Machine 
		
		- Remote Repository Server :
		
				GITHUB 	- is one of the Remote Repositories
				GITLAB 
				AZURE Repo 
				AWS Code Commit 
				BitBucket 
				
	Working with GIT :
	
	- GIT File Workflow 
	- GIT Cli Command 
	- GIT Branching Techniques
	- Handling Remote Github Repositories
	
	

	- GIT File Workflow :: 60%
	
	
	Distributed VCS :
	
	
	Local Machine 																		Remote Server 
	
	
	Working Directory			Staging_Area				Local-Repository 				Remote-Repository
	
	
	index.html------------------>index.html----------------->index.html_v1.0---------------->index.html_v1.0
					git add 					git commit						git push
	index.html------------------>index.html----------------->index.html_v1.1---------------->index.html_v1.1
					git add 					git commit						git push
	index.html------------------>index.html----------------->index.html_v1.2---------------->index.html_v1.2
					git add 					git commit						git push
	index.html------------------>index.html----------------->index.html_v1.3---------------->index.html_v1.3
					git add 					git commit						git push
	index.html------------------>index.html----------------->index.html_v1.4---------------->index.html_v1.4
					git add 					git commit						git push
	
	
	Developer ::
	
		Developers' Workload :
		
		- Enhancement Projects / Bugfixing Projects 

		- New Project 
		
		


	GIT Cli Commands :
	
	
	- git clone				# To Copy/Clone the entire Remote Repository to Local Machine
	
	- git add 				# To Add the Changes from working directory to staging area 
	
	- git commit 			# To Commit the Changes from Staging_Area to Local Repository
	
	- git push				# To Push the Changes from Local Repository to Remote-Repository
	
	- git fetch/git pull :
	
			- Both git fetch and git pull are used to handle the incremental changes from Remote-Repository 
	
			- git Fetch :
					- It is used to check for the incremental changes in the remote repository, if there is any incremental changes exist, it will just update the details about the changes only in the Local Repository Not in the Working Directory.
					
					Using git Merge we can update the working directory from local repository
					
			- git Pull :
					- It is used to check for the incremental changes in the remote repository, if there is any incremental changes exist, it will update the details about the changes in the Local Repository as well in the Working Directory.	

					git pull = git fetch + git merge 					
					
	- git init 				# To initialize a Local Repository	
	
	- Fork 					# To Copy a remote repository to another remote repository
	
	
	
	Remote Repository :
	
		index.html 		--> 10 Lines of Code 
		
						--> 10 KB 
						
							20KB	20 Lines		==> Push to Remote Repos 
						
						
	 git clone :
	 
		
		Local Machine ==> 10 KB - 10 Lines 
		
							+ 10Lines 
							
							20KB			==> Push to Remote Repos 
							

	Install GIT :::
	
		https://git-scm.com/downloads
		
		git --version 		
		
		Windows Machine :
		
			- GIT BASH  --> Based on Linux Bash Shell   ********
			- GIT CMD 	--> Based on Windows PowerShell 
			- GIT GUI 	--> GUI Tool 
			
	
	Working with GIT Local Repositories using GIT Client :::
	
		git --version
		
		Project Folder/Directory :
		
		
			d: 
			
			cd d:
			
			mkdir Paperlive-Projects 
			
			cd Paperlive-Projects
			
			mkdir Repo1 
			
			mkdir Repo2 
			
			mkdir Repo3 
			
			cd Repo1
			
			git init 
			
		
			git init 
			
				- git init				# 	To initialize the git repository 
											Create .GIT Directory 
											Create Default Branch - master branch.
			
			git status					# Get the current status of local repository
		
	
	
	Local Machine 																
	
	
	Working Directory			Staging_Area				Local-Repository
	
	
	file1.txt------------------> <file1.txt> -----------------> file1.txt_v1.0
	
					git add 					git commit 
					
					
			git add file1.txt 
			
			git commit -m "Created file1.txt"
			
			git log 




************************
Day 12 : 13th Feb. 2025 
************************	


	Git Continued.........
	
	
	
	- Create Local Repositories 
	
	Local Machine 																
	
	
	Working Directory			Staging_Area				Local-Repository
	
	
	file1.txt------------------> <file1.txt> -----------------> file1.txt_v1.0
	
	
	git init	
	
	
	Git Configuration :
	
	
		- Local Configuration			# It is applicable within a repository 
		
			git config user.name "Loksai"
			
			git config user.email "Loksai@asdfs.com"
			
		
		- Global Configuration			# It is applicable to all the Repositories 
	
			git config --global user.name "Loksai"
			
			git config --global user.email "Loksai@asdfs.com"	
			
			
	echo "rec" >> file1.txt 
	
	git add file1.txt 
	
	git commit -m "Created file1.txt"
	
	
	For the very first time :::
	
	
		git init	

		echo "rec" >> file1.txt 
		
		git add file1.txt 	

		git config --global user.name "Loksai"
		
		git config --global user.email "Loksai@asdfs.com"	
		
		git commit -m "Created file1.txt"
		
	
	
	GIT ADD :::
	
	
		git add <file1.txt> 
		
		git add <file1.txt> <file2.txt> <file3.txt>
		
		git add *.doc 
		
		git add .										# Add all the files to the Staging Area.
	
	
	
	UnStaging :		To remove file from staging area 
	
	
		git rm --cached a1.java 			
				# Removes the file changes from staging area and the changes will be taken back to working directory as UnTracked Changes.
		
		git rm -f a2.java 

				# Removes the file changes from staging area as well as from the working directory.
	
	
	ls 				# Linux Command to list the files/dir
	
	git ls-files	# Is used to get the list of files that are being tracked by git.
	
	git status 		# Used to get the current status of a repository 
	
	
	
	GIT LOG :::		# Used to Track the changes/Get the list of commits from a repository
	
		git log 
		
		git log --oneline
		
		git log -3
		
		git log --oneline -2
		
		git log --stat -1		

	git show <commit_id>
	
	
	GIT Reset / Revert ::::		Both are used to undo the committed changes from GIT Repositories
	
	git reset :::
	
		git reset is used to undo the changes from the repository
		git reset will reset the commit point to the previous commit point 
		git reset will not create any new commit point for track purpose 
		git reset is not recommended in the shared repository 
		
		Use git reset --hard only if you are sure about the changes. 
			
	
		Syntax :		
			- git reset <reset_option> <previous_Commit_ID>
			
		Reset Options ::
		
			git reset --soft <previous_Commit_ID> :::
				- git reset will reset the HEAD pointer to the previous commit point.
				- It will take the changes back to staging area 
				- The Changes will be available in staging area and working directory					
		
			git reset --mixed <previous_Commit_ID> :::										#Default
				- git reset will reset the HEAD pointer to the previous commit point.
				- It will take the changes back to working directory 
				- The Changes will be available only in working directory			
			
			git reset --hard  <previous_Commit_ID> :::
				- git reset will reset the HEAD pointer to the previous commit point.
				- It will permanently delete the files from the system 
	


	ETL  :::

		Monitoring Server! --> Monitor my prod workload for every 10 mins
		
			Generate the data feed!	raw content 
			
			Extract raw content into a Repository 			Repo - Initial Commit --> CM1
							Repo :
								CM1 			# Have the Extracted data 
								Initial_Commit
					
							git reset --hard Initial_Commit
		
			Tranform it & save in a Relation DataBase 
			
			Loaded to Target Server!
		

	git revert :::
	
		- Git Revert is same as git reset --hard option 		
		- git revert is used to undo a specific commit 		
		- git revert will create a new commit point for tracking purpose.		
		- git revert will maintain the commit history		
		- git revert is recommended in shared repositories
		
		Syntax ::
			git revert <specific_Commit_ID>	
			

Next: 

	Continued with GIT	
	
  576  mkdir samplerepo1
  577  cd samplerepo1/
  578  clear
  579  git init
  580  ls -a
  581  ls
  582  echo "rec1" >> file1.txt
  583  git status
  584  git add file1.txt
  585  git status
  586  git commit -m "Created file1.txt"
  587  git log
  588  ls
  589  echo "rec1" >> file2.txt
  590  git add file2.txt
  591  git commit -m "Created file2.txt"
  592  git log
  593  clear
  594  git log
  595  git config user.name "Loksai"
  596  echo "rec1" >> file3.txt
  597  git add file3.txt
  598  git commit -m "Created File3.txt"
  599  git log
  600  cd ..
  601  mkdir samplerepo2
  602  cd samplerepo2/
  603  git init
  604  echo "rec1" >> s1.txt
  605  git add s1.txt
  606  git commit -m "Created S1.txt"
  607  git log
  608  clear
  609  git log
  610  ls
  611  clear
  612  git status
  613  ls
  614  echo "rec1" >> s2.txt
  615  ls
  616  echo "rec1" >> s3.txt
  617  echo "rec1" >> s4.txt
  618  echo "rec1" >> s5.txt
  619  echo "rec1" >> a1.java
  620  echo "rec1" >> a2.java
  621  echo "rec1" >> a3.java
  622  echo "rec1" >> a4.java
  623  echo "rec1" >> q1.doc
  624  echo "rec1" >> q2.doc
  625  echo "rec1" >> q3.doc
  626  echo "rec1" >> q4.doc
  627  echo "rec1" >> w1.md
  628  echo "rec1" >> w2.md
  629  echo "rec1" >> w3.md
  630  echo "rec1" >> w4.md
  631  clear
  632  ls
  633  git status
  634  git add a1.java a2.java
  635  git status
  636  git add *.java
  637  git status
  638  git add *.md q1.doc
  639  git status
  640  git add .
  641  git status
  642  git rm --cached a1.java
  643  git status
  644  git add .
  645  git status
  646  git rm -f a1.java
  647  git status
  648  ls
  649  ls
  650  git ls-files
  651  git rm --cached a2.java
  652  ls
  653  git ls-files
  654  git status
  655  git add .
  656  git commit -m "Created few files!"
  657  git log
  658  clear
  659  echo "rec1" >> m1.py
  660  git add .
  661  git commit -m "Created m1.py"
  662  echo "rec1" >> m2.py
  663  git add .
  664  git commit -m "Created m2.py"
  665  echo "rec1" >> m3.py
  666  git add .
  667  git commit -m "Created m3.py"
  668  echo "rec1" >> m4.py
  669  git add .
  670  git commit -m "Created m4.py"
  671  echo "rec1" >> m5.py
  672  git add .
  673  git commit -m "Created m5.py"
  674  echo "rec1" >> m6.py
  675  git add .
  676  git commit -m "Created m6.py"
  677  clear
  678  git log
  679  clear
  680  git log
  681  git log --oneline
  682  git log
  683  git log -2
  684  git log -5
  685  git log --oneline -2
  686  celar
  687  clear
  688  git log --oneline -2
  689  git show 8ba251d
  690  echo "rec2" >> m6.py
  691  git add .
  692  git commit -m "Updated m6.py"
  693  git log --oneline -3
  694  git show 09dcb8f
  695  clear
  696  git log --stat -1
  697  git show 09dcb8f
  698  clear
  699  git diff
  700  cat m6.py
  701  echo "rec3" >> m6.py
  702  cat m6.py
  703  git status
  704  git diff
  705  cat m6.py
  706  echo "rec4" >> m6.py
  707  cat m6.py
  708  git diff
  709  git add .
  710  git commit -m "Updated m6.py"
  711  clear
  712  git diff
  713  git status
  714  git log
  715  clear
  716  git log -2
  717  git log --oneline -2
  718  clear
  719  ls
  720  git status
  721  git commit -m "asdf"
  722  clear
  723  clear
  724  git log
  725  clear
  726  cd ..
  727  clear
  728  mkdir samplerepo3
  729  cd samplerepo3/
  730  clear
  731  git init
  732  echo "rec1" >> s1.txt
  733  git add .
  734  echo commit -m "CM1"
  735  git commit -m "CM1"
  736  clear
  737  git log --oneline
  738  s
  739  clear
  740  ls
  741  echo "rec1" >> s2.txt
  742  git add .
  743  git commit -m "CM2"
  744  echo "rec1" >> s3.txt
  745  git add .
  746  git commit -m "CM3"
  747  echo "rec1" >> s4.txt
  748  git add .
  749  git commit -m "CM4"
  750  echo "rec1" >> s5.txt
  751  git add .
  752  git commit -m "CM5"
  753  clear
  754  git log --oneline
  755  ls
  756  git ls-files
  757  git status
  758  git reset --soft 4265497
  759  ls
  760  git ls-files
  761  git status
  762  git log --oneline
  763  git commit -m "CM5.1"
  764  git status
  765  git ls-files
  766  ls
  767  git log --oneline
  768  git reset --mixed 4265497
  769  git status
  770  git ls-files
  771  ls
  772  git log --oneline
  773  git add .
  774  git commit -m "CM5.2"
  775  git status
  776  ls
  777  git ls-files
  778  git log --oneline
  779  git reset --hard 4265497
  780  git status
  781  git ls-files
  782  ls
  783  git log --oneline
  784  git reset --hard 1962e69
  785  git log --oneline
  786  ls
  787  git reset --hard 22d27e9
  788  ls
  789  git ls-files
  790  git log --oneline
  791  git status
  792  ls
  793  git log
  794  git log --oneline
  795  clear
  796  git log
  797  ls
  798  clear
  799  ls
  800  git log --oneline
  801  echo "rec1" >> s1.txt
  802  echo "rec1" >> q1.txt
  803  git add .
  804  git commit -m "CM2"
  805  echo "rec1" >> q2.txt
  806  git add .
  807  git commit -m "CM3"
  808* echo "rec1" >> q.txt
  809  git add .
  810  git commit -m "CM4"
  811  clear
  812  git log --oneline
  813  ls
  814  git show 547b129
  815  git revert 547b129
  816  git log --oneline
  817  git status
  818  git ls-files
  819  ls
  820  git show 61c538c
  821  git log --oneline
  822  ls
  823  git revert 61c538c
  824  ls
  825  git log --oneline
  826  clear
  827  cd ..
  828  history	
	
	
	


************************
Day 13 : 14th Feb. 2025 
************************


	git commit :::
	
		git commit -m "Commit_Message"
		
		Best Practises :
		
		
			- Commit Message should be relevant to the Changes. 
			
			Project_ID 
			
			Change_Request_Number 
			
			
			git commit -m "CR-1001 Updated Payment_Script"
			
			git commit -m "CR-1002 Updated Loan_Script"			

			git commit -m "Proj-202502 Updated Payment_Script"
			
			
			Commits --> 
			
				git commit -m "asdfasfd" 
				
				git commit --amend -m "Valid_Commit_Message"
				
			cm3			Latest --> --amend 	
			cm2
			cm1
	
	
	
	GIT IGNORE :::
	
	
		-> Is used to ignore the files from tracking! 
		-> If you don't want git to track any file, just create .gitignore file and save the file names/fiel name patterns.
		
		-> As a best Practises - .gitignore file should be the initial commit for any repository
		
		
		Project Components :
		
		
		Project Workspace/Folder :::
		
		Python_Project_Folder 
		
			app.py 
			templates
				index.html 
		
		
		
		vi .gitignore file
		
			*.war
			DBase_UserName 
			DBase_Password 
			DB_Secret.json	
		
		
		Local Machine :
		
																								Push
		Working Directory 			----> 	Staging_Area		---->	Local_Repository 	====================> 	Remote_Repository 
		
		Java_Maven_Project_Folder 
		
			src 
				main 
					*.java
				test 
					*.java 
			target 
				*.war
				*.jar 
			application.properties 
			*.doc
			DBase_UserName 
			DBase_Password 
			DB_Secret.json
		
	
		git reset :
		
					Repo :
						CM4 			# Have the Extracted data 
						CM3 			# Have the Extracted data 
						CM2 			# Have the Extracted data 					
						CM1 			# Have the Extracted data 
						Initial_Commit	# .gitignore	
		
		
			git reset --hard Initial_Commit
		
					Repo :
						Initial_Commit	# .gitignore	
						
						
	GIT Branching Techniques :::
	
		- Git Branches are used to independently work on any changes 
		- Git Branches are used to perform parallel development 
		
		In Distributed VCS, Branches are used to perform parallel Development 	
		
		Default Branch - master - is considered as a production version of source code.	
		
	
	GIT Branching Strategies :::
	
		--> Used to perform parallel development without impacting the integrity of the master branch
		
	GIT Branching Strategies :::
	
	
	Scenario 1:	--> single user and single feature 
	
		--> Repo1 :
		
				master - cm1,cm2,cm3
				
	Scenario 2: --> single user with single feature 
		
		--> Repo1 :
		
				master - cm1,cm2,cm3
				
						cm1,cm2,cm3,f1cm1,f1cm2,f1cm3			# Upon Merging from feature_branch1
				
	
					feature_branch1 - cm1,cm2,cm3,f1cm1,f1cm2,f1cm3			file1.txt
					
						git merge feature_branch1
				

	
	
	Scenario 3: --> single user with multiple features 
	

		--> Repo1 :
		
				master - cm1,cm2,cm3

					Developer1_Branch - cm1,cm2,cm3
										- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
					
						feature_branch1 - cm1,cm2,cm3
										- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
						
						feature_branch2 - cm1,cm2,cm3
										- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
	


	Scenario 4: --> Multiple users with multiple features 
	

		--> Repo1 :
		
				master - cm1,cm2,cm3
						cm1,cm2,cm3,cm4									# cm4 is the integration of Developer1&2 Changes		
				
					Integration_Branch - cm1,cm2,cm3 
										- cm1,cm2,cm3,Developer1-Changes,Developer2-Changes					

						Developer1_Branch - cm1,cm2,cm3
											- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
						
							feature_branch1 - cm1,cm2,cm3
											- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
							
							feature_branch2 - cm1,cm2,cm3
											- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	

						Developer2_Branch - cm1,cm2,cm3
											- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
						
							feature_branch1 - cm1,cm2,cm3
											- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
							
							feature_branch2 - cm1,cm2,cm3
											- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
											

	Scenario 5:	

		--> Repo1 :
		
				master - cm1,cm2,cm3
					- cm1,cm2,cm3,cm4									# cm4 is the integration of Team1&Team2 Changes 
				
					Release_Branch - cm1,cm2,cm3
									cm1,cm2,cm3,Team1-Changes,Team2-Changes	
				
						Integration_Branch1 - cm1,cm2,cm3 												# Team1					
											- cm1,cm2,cm3,Developer1-Changes,Developer2-Changes					

							Developer1_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	

							Developer2_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
												
						Integration_Branch2 - cm1,cm2,cm3 												# Team2				
											- cm1,cm2,cm3,Developer1-Changes,Developer2-Changes					

							Developer1_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	

							Developer2_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
												
												
	Working with Git Branches :::
	
	Create Branch :
	
		git branch 								# List the branches 
		
		git branch <New_Branch_Name>			# Create a branch  
		
		git switch -c <New_Branch_Name>			# Create a branch & Switch to New Branch
		
		git switch <existing_Branch_Name>		# Switch to specific
		
		
		
		git init 
		
		git branch feature1 
		
		git branch feature2
		
		git switch feature1 
		
		Repo1 :
		
			master ==> cm1 
			
			
			
				feature1  -->	cm1
								cm1,f1cm1 
								
						git switch master 
						
						git merge feature1				# Merge Command should be executed from target branch
					
				
				feature2  -->   cm1
				
				
	 Merge Conflict :
	 
	 
		--> 	When we try to merge the change from more than once feature/user into the same file at the same record level to the target branch 
		
		
	Handle / Fix Merge Conflict :
	
		--> Identify the file(s) causing the merge conflict 
		
		--> Open and Review the File Content 
		
		--> Decide which feature/user changes to be retained or removed from that file 
		
		--> Edit the file, delete the header and footer lines, update and save the file content accordingly 
		
		--> Perform GIT ADD and Commit the Changes in Target Branch.
		
	
	
	DevOps Perspectives :
	
		--> Prevent Merge Conflict :::
		
				- With Proper collaboration and review before merge.

  835  mkdir testrepo1
  836  clear
  837  cd testrepo1/
  838  clear
  839  git init
  840  echo "rec1" >> f1.txt
  841  git add .
  842  git commit -m "asdfasdf"
  843  clear
  844  git log
  845  git commit -m "Created f1.txt"
  846  git log --oneline
  847  ls
  848  git commit --amend -m "Created f1.txt"
  849  git log --oneline
  850  clear
  851  git log
  852  ls
  853  clear
  854  cd ..
  855  mkdir testrepo2
  856  clear
  857  cd testrepo2/
  858  git init
  859  git status
  860  ls -a
  861  vi .gitignore
  862  cat .gitignore
  863  git status
  864  git add .
  865  git commit -m "Initial Commit for .gitignore"
  866  clear
  867  ls
  868  ls -a
  869  cat .gitignore
  870  echo "rec1" >> file1.java
  871  ls
  872  git status
  873  echo "rec1" >> sample.txt
  874  ls
  875  git status
  876  echo "rec1" >> s1.doc
  877  git status
  878  ls
  879  git add .
  880  ls
  881  git status
  882  git commit -m "Created file1.java"
  883  git status
  884  ls
  885  git ls-files
  886  clear
  887  git branch
  888  git branch
  889  git branch feature1
  890  git branch
  891  git switch -c feature2
  892  git branch
  893  git switch master
  894  git branch
  895  git branch
  896  git switch feature3
  897  git log --oneline
  898  ls
  899  clear
  900  cd ..
  901  ls
  902  mkdir testrepo3
  903  cd testrepo3
  904  git init
  905  clear
  906  git status
  907  ls
  908  git branch
  909  echo "rec1" >> file1.txt
  910  git add .
  911  git commit -m "CM1"
  912  clear
  913  ls
  914  git branch
  915  git log --oneline
  916  git status
  917  ls
  918  git branch feature1
  919  git branch
  920  git log --oneline
  921  ls
  922  cat file1.txt
  923  git switch feature1
  924  git log --onelne
  925  git log --oneline
  926  ls
  927  cat cat file1.txt
  928  cat file1.txt
  929  clear
  930  git switch master
  931  clear
  932  git branch
  933  git branch feature2
  934  git log --oneline
  935  ls
  936  git switch feature1
  937  git log --oneline
  938  ls
  939  cat file1.txt
  940  echo "rec2 from feature1" >> file1.txt
  941  git status
  942  git add .
  943  git commit -m "f1cm1"
  944  cat file1.txt
  945  git status
  946  git log --oneline
  947  git switch master
  948  git log --oneline
  949  cat file1.txt
  950  git switch feature1
  951  ls
  952  cat file1.txt
  953  clear
  954  git log --oneline
  955  cat file1.txt
  956  git switch master
  957  git log --oneline
  958  cat file1.txt
  959  git merge feature1
  960  git log --oneline
  961  cat file1.txt
  962  git switch feature2
  963  cat file1.txt
  964  git log --oneline
  965  echo "rec2 from feature2" >> file1.txt
  966  git add .
  967  git commit -m "f2cm1"
  968  git log --oneline
  969  git switch master
  970  cat file1.txt
  971  git log --oneline
  972  git merge feature2
  973  git log --oneline
  974  clear
  975  git status
  976  cat file1.txt
  977  vi file1.txt
  978  git add .
  979  git commit -m "Fixed Merge Conflict"
  980  cat file1.txt
  981  git log --oneline
  982  clear
  983  cd ..
  984  history


				
************************
Day 14 : 17th Feb. 2025 
************************

	GIT Way of preventing Merge Conflicts in target branch!
	
	GIT REBASE :
	
		git rebase ::::
		
			- Used to maintain the linear commit history.
			- Used to Sync the current branch with the target branch.
			- Used to prevent merge conflicts in the target branch.
			
			- As a best practise it is always recommended to use rebase before merge!
			
		Repo1 :
		
			master - cm1,cm2 
			
					- cm1,cm2,f1cm1,f1cm2,f1cm3							# Upon merging feature1 
					
					- cm1,cm2,f2cm1,f2cm2,f2cm3,f1cm1,f1cm2,f1cm3		# Upon merging feature2 branch without rebase 
			
					- cm1,cm2,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3		# Expected Linear Commit history 
																		# Upon merging feature2 branch with proper rebase
			
				feature1 - cm1,cm2
				
						- cm1,cm2,f1cm1,f1cm2,f1cm3
						
						git switch master 						
						git merge feature1 		
				
				
				feature2 - cm1,cm2
				
						- cm1,cm2,f2cm1,f2cm2,f2cm3
						
						git rebase master 					# Should be executed from current branch						
						
						- cm1,cm2,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3						
						
						git switch master 
						
						git merge feature2 			
		
		
		
	- GIT SQUASH Option :		
	
		- Git Squash Option is used to combine more than one commits into single commit point.
	
		Repo1 :
		
			master - cm1,cm2 		
			
					cm1,cm2,f1cm1,f1cm2,f1cm3,.....................,f1cm500			# Upon merging feature1 
					
					cm1,cm2,cm3								# Upon merging feature1 using --squash option 
															# cm3 is the combination of feature1 commits
			
				feature1 - cm1,cm2,f1cm1,f1cm2,f1cm3,.....................,f1cm500		
				
					git switch master 
					
					git merge --squash feature1
					
					git commit -m "New Commit_Message"
					
	   Scenario 5:	

		--> Repo1 :
		
				master - cm1,cm2,cm3
					- cm1,cm2,cm3,cm4									# cm4 is the integration of Team1&Team2 Changes 
				
					Release_Branch - cm1,cm2,cm3
									cm1,cm2,cm3,Team1-Changes,Team2-Changes	
				
						Integration_Branch1 - cm1,cm2,cm3 												# Team1					
											- cm1,cm2,cm3,Developer1-Changes,Developer2-Changes					

							Developer1_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	

							Developer2_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
												
						Integration_Branch2 - cm1,cm2,cm3 												# Team2				
											- cm1,cm2,cm3,Developer1-Changes,Developer2-Changes					

							Developer1_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	

							Developer2_Branch - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3,f2cm1,f2cm2,f2cm3	
							
								feature_branch1 - cm1,cm2,cm3
												- cm1,cm2,cm3,f1cm1,f1cm2,f1cm3
								
								feature_branch2 - cm1,cm2,cm3
												- cm1,cm2,cm3,f2cm1,f2cm2,f2cm3	
					
		
	- GIT Cherry-Pick :		
			# Used to Merge specific commit(s) to the target branch 
			# As per best practise, it is NOT recommended to use cherry-pick!
	
	
		git merge feature1 		
		
		git cherry-pick <commit_id>
		
		git cherry-pick <commit_id1> <commit_id1>
		
	
	
	- GIT Stash ::::
	
		--> Is used to save the uncommitted changes to the temporary area.
		
		Repo 1:
		
			master - cm1,cm1 
			
				feature1 :
				
				feature2 :
				
				
			git stash save "Stash Message"		# Create Stash entry in the Stash list 
			
			git stash list 						# Used to get the list stash entries 
			
			
			git stash apply 					# Used to Apply/Copy the latest entry from the stash list to staging area
			
			git stash apply stash@{2}			# Used to Apply/Copy a specific entry from the stash list to staging area
			
			git stash drop						# Used to delete the latest entry from the stash list			
			
			git stash drop stash@{2}			# Used to delete a specific entry from the stash list		
		
			git stash pop						# Used to apply the latest entry from the stash list to staging area
												# Delete the  latest entry from the stash list
						
			git stash pop stash@{2}				# Used to apply a specific entry from the stash list to staging area
												# Delete a specific entry from the stash list
												
			git stash clear						# Clean-up the Stash list 
			
			
			
	
	
	- Remote Repositories :
	
		Work with Remote and Local Repositories 
		
		Developers' Workload :
		
		- Enhancement Projects / Bugfixing Projects 

		- New Project 	


		GIT CLI Commands :
		
			- git clone				# To Copy/Clone the entire Remote Repository to Local Machine
			
			- git add 				# To Add the Changes from working directory to staging area 
			
			- git commit 			# To Commit the Changes from Staging_Area to Local Repository
			
			- git push				# To Push the Changes from Local Repository to Remote-Repository
			
			- git fetch/git pull :
			
					- Both git fetch and git pull are used to handle the incremental changes from Remote-Repository 
			
					- git Fetch :
							- It is used to check for the incremental changes in the remote repository, if there is any incremental changes exist, it will just update the details about the changes only in the Local Repository Not in the Working Directory.
							
							Using git Merge we can update the working directory from local repository
							
					- git Pull :
							- It is used to check for the incremental changes in the remote repository, if there is any incremental changes exist, it will update the details about the changes in the Local Repository as well in the Working Directory.	

Next ::
				
	Handling Remote-Repositories :::		
				
		- Enhancement Projects / Bugfixing Projects 
		
			- Create a Remote git repository :
			
				- Github Account


  501  cd d:
  502  cd paperlive-projects/
  503  ls
  504  clear
  505  ls
  506  mkdir demorepo1
  507  celar
  508  clear
  509  cd demorepo1/
  510  clear
  511  git init
  512  echo "rec1" >> f1.txt
  513  git add .
  514  git commit -m "cm1"
  515  echo "rec1" >> f2.txt
  516  git add .
  517  git commit -m "cm2"
  518  clear
  519  git log --oneline
  520  ls
  521  git status
  522  git branch feature1
  523  git branch feature2
  524  git switch feature1
  525  clear
  526  git log --oneline
  527  echo "rec1" >> s1.txt
  528  git add .
  529  git commit -m "f1cm1"
  530  echo "rec1" >> s2.txt
  531  git add .
  532  git commit -m "f1cm2"
  533  echo "rec1" >> s3.txt
  534  git add .
  535  git commit -m "f1cm3"
  536  clear
  537  git log --oneline
  538  git rebase master
  539  git switch master
  540  git merge feature1
  541  git log --oneline
  542  ls
  543  git switch feature2
  544  git log --oneline
  545  echo "rec1" >> q1.txt
  546  git add .
  547  git commit -m "f2cm1"
  548  echo "rec1" >> q2.txt
  549  git add .
  550  git commit -m "f2cm2"
  551  echo "rec1" >> q3.txt
  552  git add .
  553  git commit -m "f2cm3"
  554  echo "rec1" >> q4.txt
  555  git add .
  556  git commit -m "f2cm4"
  557  git log --oneline
  558  git rebase master
  559  git log --oneline
  560  git rebase master
  561  git switch master
  562  git log --oneline
  563  git merge feature2
  564  git log --oneline
  565  ls
  566  git switch feature1
  567  git log --oneline
  568  ls
  569  git rebase master
  570  git log --oneline
  571  clear
  572  git status
  573  git log --oneline
  574  clear
  575  echo "rec1" >> l1.txt
  576  git add .
  577  git commit -m "f1commit1"
  578  echo "rec1" >> l2.txt
  579  git add .
  580  git commit -m "f1commit2"
  581  echo "rec1" >> l3.txt
  582  git add .
  583  git commit -m "f1commit3"
  584  echo "rec1" >> l4.txt
  585  git add .
  586  git commit -m "f1commit4"
  587  echo "rec1" >> l5.txt
  588  git add .
  589  git commit -m "f1commit5"
  590  clear
  591  git log --oneline
  592  git rebase master
  593  git switch master
  594  git merge --squash feature1
  595  git status
  596  git commit -m "Create l*.txt files"
  597  git log --oneline
  598  ls
  599  git show 49bc7df
  600  clear
  601  git status
  602  cd ..
  603  mkdir demorepo2
  604  cd demorepo2/
  605  git init
  606  clear
  607  git status
  608  echo "rec1" >> q1.txt
  609  git add .
  610  git commit -m "Created q1.txt"
  611  cleatr
  612  clear
  613  git switch -c feature1
  614  git log --oneline
  615  ls
  616  echo "rec1" >> w1.txt
  617  echo "rec2" >> w1.txt
  618  echo "rec3" >> w1.txt
  619  git add .
  620  clear
  621  ls
  622  git status
  623  git switch master
  624  git status
  625  git switch feature1
  626  ls
  627  git status
  628  git stash list
  629  git stash save "for w1.txt"
  630  git stash list
  631  git status
  632  ls
  633  git stash list
  634  echo "rec1" >> w2.txt
  635  git add .
  636  echo "rec1" >> w3.txt
  637  git stash save "for w2.txt"
  638  ls
  639  git status
  640  git add .
  641  git stash save "for w3.txt"
  642  git stash list
  643  echo "rec1" >> w4.txt
  644  git add .
  645  git stash save "for w4.txt"
  646  git stash list
  647  ls
  648  git status
  649  git switch master
  650  ls
  651  git status
  652  git switch feature1
  653  ls
  654  git stash list
  655  git stash apply
  656  git status
  657  ls
  658  git commit -m "created w4.txt"
  659  git status
  660  ls
  661  git stash list
  662  git stash drop
  663  git stash list
  664  ls
  665  git stash pop
  666  git status
  667  git stash list
  668  clear
  669  git status
  670  git stash list
  671  git stash save "for w3.txt"
  672  echo "rec1" >> d1.txt
  673  git add .
  674  git stash save "for d1.txt"
  675  echo "rec1" >> d2.txt
  676  git add .
  677  git stash save "for d2.txt"
  678  echo "rec1" >> d3.txt
  679  git add .
  680  git stash save "for d3.txt"
  681  clear
  682  git stash list
  683  git status
  684  ls
  685  git stash apply stash@{2}
  686  git commit -m "created d1.txt"
  687  git status
  688  git stash list
  689  git stash drop stash@{2}
  690  git stash list
  691  git stash pop stash@{2}
  692  git stash list
  693  git stash clear
  694  git stash list
  695  clear
  696  cd ..
  697  clear
  698  history


