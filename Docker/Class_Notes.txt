
************************
Day 21 : 28th Feb. 2025 
************************

	Containerization using Docker ::::
		
		
	- Containerization :	It is process of packaging the Application along with its dependencies.
	
	
	- Virtual Machines :::
	
		- VMs are Hardware Level Virtualization 
		- VMs are created using Hypervisor 
		- VMs are used to execute Operating System
		- VMs will continue to run, even if there is no active Application/Task
		- VMs will consume More Space and Time to start the application/task
	
	- Containers :::
	
		- Containers are OS Level Virtualization 
		- Containers are created using Container Engine  
		- Containers are used to run the Application/Task. NOT Operating System
		- If there is not Active Task/Application, Contianers will immediately go to EXIT State.
		- Containers will consume less Space and Time to start the application/task	
		
		- Container are used to Deploy any Micro-Service Based Application Services.
		
		- Contianers run in its' own isolated address space.
		
			- By using underlying properties of Operating System :
					- Name Space					
					- Control Group 
	
	
	Terminologies / Architecture Components :
	
		Container Engine		# Is used to Create and Manage the Container Images and Containers
								# Docker Container Engine 
	
		Containerization 		# It is process of packaging the Application along with its dependencies.
		
		Container Image 		# Is a static file that defines the properties and dependencies of application to create a container.
								# Images are Non-Executable
								# Images composed of various Layer of Instructions
							
		Container				# Is an Executable unit of Container Image 
		
		Container Registry		# Is used to manage/save/version control the Container Images
								# DockerHub is one of the Container Registries
								# Create DockerHub Account 
									https://hub.docker.com/
		
		Container Repository	#	It is subset of Container Registry
		
	
	
	Infra-structure Perspectives :
	
		Jenkins :	Master-Slave Architecture
		
			Jenkins_Master (VM)				==> Install git,jdk,jenkins
					Jenkins_Slave_Node1 (VM)	==> Java Application Build 
					Jenkins_Slave_Node2 (VM)	==> Python Application Build 
					Jenkins_Slave_Node3 (VM)	==> .Net Application Build 
					Jenkins_Slave_Node4 (VM)	==> Angular Application Build 
					Jenkins_Slave_Node5 (VM)	==> NodeJS Application Build 

			Jenkins_Master (VM)				==> Install git,jdk,jenkins
			
				Jenkins_Slave_Node1 (VM)
					- Install Container Engine 
							C1 				==> Java Application Build 
							C2              ==> Python Application Build 
							C3              ==> .Net Application Build 
							C4              ==> Angular Application Build 
							C5              ==> NodeJS Application Build 
							
							
	Developer's / Deployment Perspectives :
	
			Non-Prod Environments	::

			
		
				Dev Environment		
							Create Source Code :
							
							Build : Compile & Create Artifacts 			mywebapp1.war
							Unit Level Testing 
							
							Jdk17,Tomcat8.5 -- Run *.war
							
							Containerization ::: It is process of packaging the Application along with its dependencies.
							
							
							Package/Container Image --> mywebapp1-img1 ( mywebapp1.war,jdk17,tomcat8.5)
							
							Save the Container Image mywebapp1-img1 in the DockerHub Container Registry
							
							

					QA 		# Upon Deployment of Image mywebapp1-img1
						
							
							Container Engine 
						
								Create Application Container using Image mywebapp1-img1
								
								
						
Next :

	Install Container Engine 
	DockerHub Access 
	
	Docker Cli Commands 



************************
Day 22 : 28th Feb. 2025 
************************


	- DockerHub --> Explore the Images 
	
		github 						==> Version Control Source-Codes		*.java_v1.0		*.java_v1.1
		
		
		Artifactory Library 		==> Version Control Artifacts			*.war_v1.0 		*.war_v1.1	
		(jfrog/azArtifact)
		
		Container Registry 			==> Version Control Container Images	app-img_v1.0	app-img_v1.1
		(DockerHub)
		
	Open-Source: 	DockerHub 
	
	Managed Services:
	
	AWS 	--> ECS/ECR/EKS
	Azure 	--> ACS/ACR/AKS
	GCP		--> GCE/GCR/GKE
	
	
	
	
	- Install Container Engine in Linux Machine 			# https://docs.docker.com/engine/install/
	
	
	sudo apt install docker.io -y	
	
		Install in Jenkins_Slave_Node1			# git/jdk/maven/ docker engine 
		
	
	- Docker CLI Commands :::			# To Interact with Docker Engine 
	
	
	docker --version
	
	
	docker images 				# Get the List of Images in local machine 
	
	docker ps 					# Get the List of Active Containers 
	
	docker ps -a 				# Get the List of all Container(Active/Exit)
	
	docker pull <image_name>	# To download a container image from dockerhub to local machine 
	
	docker run <image_name>		# To Create and execute/run the Container based on the Container Image 
	
	
	Three Modes of run Command :
	
		- Foreground / Active Mode : Hold the Terminal - Run the container in Active Terminal 	# Default
		
			- Syntax: 
			
				docker run <image_name> 		
		
		- Background / Detached Mode : To run the container in background mode 
		
				docker run -d <image_name> 
		
		- Interactive Mode :	To run the container in interactive mode to access 
		
				docker run -it <image_name> bash 
				
				docker run -it ubuntu bash 
		
	docker start <container_id>
	
	docker exec 				# To Login to running Container 
	
		syntax:
		
			docker exec -it <container_id> bash 
			
		Eg.:	
		
			docker exec -it df80e7e4a315 bash
	
	
	docker stop <container_id>
				
				
				
	Port Mapping/Binding ::::
	
		- Used to map the container port with the host port. 
		- Expose the Container application to Internet.
		
		
		-p host_port:container_port 
		
		
		
		docker run -it -p 8080:8089 tomcat
		
		Port Number :::
		
		tomcat / nginx / httpd 
		8080		80		80
		
		Tomcat :
		
		docker run -it -p 8080:8089 tomcat

   17  apt install docker.io -y
   18  clear
   19  docker --version
   20  docker images
   21  docker ps
   22  docker ps -a
   23  clear
   24  docker images
   25  docker pull centos
   26  docker images
   27  docker ps
   28  docker ps -a
   29  docker run centos
   30  docker ps
   31  docker ps -a
   32  clear
   33  docker ps -a
   34  docker run centos sleep 20
   35  clear
   36  docker run centos sleep 10
   37  clear
   38  docker ps
   39  docker ps -a
   40  docker run -d centos sleep 10
   41  docker ps -a
   42  docker ps
   43  clear
   44  docker images
   45  docker ps
   46  docker ps -a
   47  docker run -it centos bash
   48  clear
   49  docker ps
   50  docker ps -a
   51  clear
   52  docker ps -a
   53  cler
   54  clear
   55  docker images
   56  docker run -it ubuntu bash
   57  clear
   58  docker ps -a
   59  docker start df80e7e4a315
   60  docker ps
   61  docker exec -it df80e7e4a315 bash
   62  docker ps
   63  docker stop df80e7e4a315
   64  clear
   65  docker images
   66  docker run -it tomcat:8.0 bash
   67  clear
   68  docker run -it -p 8080:8089 tomcat:8.0
   69  clear
   70  docker run -it -p 8080:8089 tomcat:8.0 bash
   71  docker ps
   72  clear
   73  history



************************
Day 23 : 4th Mar. 2025 
************************	

	Create Docker Container images
	
	1. docker commit 
	
		- It is used to create a Container Image based on the existing Container reference
		
		Syntax :
		
			docker commit <container_id> <new_image_name>
			
			docker commit <container_id> <dockerhub_repository_name>/<new_image_name>:<tag_no>
			
		Eg. : 
		
			docker commit df80e7e4a315 loksaieta/pl-appbuild-img:v1.0
			
	
	2. docker build :
	
		- It is used to create a Container Image using the Dockerfile definition
		- This method is used by the Developers to Containerize the Application Services 
		- Dockerfile will be created by the Developers and maintained in the Source Code Repositories
		
		Dockerfile ::
		
			- It composed of Instructions to create the layers of Container Image.
			
		
		vi Dockerfile 
		
		FROM ubuntu 
		RUN apt update -y 
		RUN apt install git -y 
		RUN apt install maven -y		
		
		save 
		
			Syntax:
			
				docker build -t <dockerhub_repository_name>/<new_image_name>:<tag_no> .			# '.' denotes the Dockerfile name
																								# Should run this command from the path where we have Dockerfile.
			
			Eg.: 
		
				docker build -t loksaieta/pl-java-appbuild-img .
				
		
		
		Dockerfile Instructions :
		
		
			- FROM 					# To identify the base image
			
			- RUN 					# Execute/Run any Package 
			
			- COPY 					# Used to Copy the files from the Host Volume to Container Volume 
			
			- CP 					# Used to Copy the files within the Container Volumes 
			
			- ADD					
					# Used to Copy the files from external URL to Container Volume as well as from the Host Volume to Container Volume 
					
			- EXPOSE				# Define the Container Port 
			
			- WORKDIR				# Is used to set the Current working directory 
			
			- ENV 					# Set the Environment Variables 
			
			- CMD 					# To define the start-up task/command to the container 
									# This Start-up task/command can be changed at runtime									
		
			- ENTRYPOINT			# To define the start-up task/command to the container 
									# This Start-up task/command cannot be changed at runtime	
									
									
									
		vi Dockerfile
		
		FROM tomcat:8.5
		COPY target/mywebapp.war /usr/local/tomcat/webapps
		EXPOSE 8089


		docker build -t loksaieta/pl-java-webapp-img .

	
	docker history <image_name>		# To get the layers of a Container Image
	
	
	Docker Volumes :::
	
	
		Persistant Data/Volume:
		
		
		On Containers perspective :
		
			- Stateless Application
					# The application that will never leave a trace of execution 
					# Basically Containers are used to run Stateless Applications
					# Containers are used to execute the tasks. Not to store any data.
					
			
			- Stateful Application 
					# The application that will leave some trace of execution 
					# Like Creating Output File / Log Files / Reports 
			
		3-Tier Application Archetecture:
		
			- Front-End Layer 	- User Interface 
			
			- Application Layer - Business Logic 
			
			- Back-End Layer	- DataBase 
			
		docker volume :
		
			- Local Volume 
				- Host Volume ::::
				
		
		docker volume list		# To get the list of Volumes 
		
		docker volume create pl-vol1 
		
		docker volume inspect pl-vol1
		
				# /var/lib/docker/volumes/pl-vol1/_data
		
		docker run -it --mount source=pl-vol1,destination=/pl-vol1 centos bash
		


Next ::

		Publish the Images 
		
		Container Orchestration 
		
			 - Docker Compose 
			 - Docker Swarm 
			 
			 - Kubernetes 

   88  clear
   89  history
   90  ckear
   91  clear
   92  docker images
   93  docker ps
   94  docker ps -a
   95  docker ps
   96  docker ps -a
   97  docker volume
   98  docker volumes
   99  clear
  100  docker volume
  101  clear
  102  docker volume list
  103  docker volume create pl-vol1
  104  docker volume list
  105  docker volume inspect pl-vol1
  106  cd /var/lib/docker/volumes/pl-vol1/_data
  107  ls
  108  cd ..
  109  clear
  110  ls
  111  cd pl-vol1/
  112  clear
  113  ls
  114  cd _data/
  115  pwd
  116  ls
  117  clear
  118  docker images
  119  clear
  120  docker run -it centos bash
  121  docker run -it --mount source=pl-vol1,destination=/pl-vol1 centos bash
  122  clear
  123  ls
  124  echo "rec1" >> hostfile1.txt
  125  ls
  126  cd ~
  127  docker run -it --mount source=pl-vol1,destination=/pl-vol1 centos bash
  128  clear
  129  history
